<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Solver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tira</a> &gt; <a href="index.source.html" class="el_package">com.jpasikainen.tira.solver</a> &gt; <span class="el_source">Solver.java</span></div><h1>Solver.java</h1><pre class="source lang-java linenums">package com.jpasikainen.tira.solver;

import com.jpasikainen.tira.logic.Board;
import com.jpasikainen.tira.logic.GameLoop;
import javafx.scene.input.KeyCode;
import javafx.util.Pair;

import java.util.ArrayList;
import java.util.Arrays;

public class Solver {
    private static class Node {
        private KeyCode move;
        private int[][] tiles;
    }
    private Node root;
    private KeyCode bestMove;

<span class="nc" id="L19">    private final int[][] weightedTiles = {{6,5,4,3}, {5,4,3,2}, {4,3,2,1}, {3,2,1,0}};//{{15,14,13,12}, {8,9,10,11}, {7,6,5,4}, {0,1,2,3}}; //</span>
<span class="nc" id="L20">    private final KeyCode[] moves = {KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN};</span>

    private GameLoop gl;

<span class="nc" id="L24">    public Solver(GameLoop gl, int[][] tiles) {</span>
<span class="nc" id="L25">        this.gl = gl;</span>
<span class="nc" id="L26">        this.root = new Node();</span>
<span class="nc" id="L27">        this.root.tiles = tiles;</span>
<span class="nc" id="L28">    }</span>

    public void solve() {
<span class="nc" id="L31">        System.out.println(expectiMiniMax(this.root, 3, true));</span>
<span class="nc" id="L32">        gl.moveTiles(bestMove);</span>
<span class="nc" id="L33">        System.out.println(bestMove);</span>
<span class="nc" id="L34">        bestMove = null;</span>
<span class="nc" id="L35">    }</span>

    private float expectiMiniMax(Node node, int depth, boolean playerTurn) {
<span class="nc" id="L38">        float alpha = 0;</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">        if (depth == 0) {</span>
<span class="nc" id="L40">            return heuristicValue(node);</span>
        }
<span class="nc bnc" id="L42" title="All 2 branches missed.">        if (playerTurn) {</span>
            // Simulate moves
<span class="nc bnc" id="L44" title="All 2 branches missed.">            for (KeyCode move : moves) {</span>
<span class="nc" id="L45">                int[][] simulatedTiles = Arrays.stream(node.tiles).map(int[]::clone).toArray(int[][]::new);</span>
<span class="nc" id="L46">                Board.moveTiles(move, simulatedTiles);</span>

                // Board changed after the move
<span class="nc bnc" id="L49" title="All 2 branches missed.">                if (Arrays.deepEquals(simulatedTiles, node.tiles)) {</span>
<span class="nc" id="L50">                    continue;</span>
                }

<span class="nc" id="L53">                Node child = new Node();</span>
<span class="nc" id="L54">                child.tiles = simulatedTiles;</span>
<span class="nc" id="L55">                child.move = move;</span>
<span class="nc" id="L56">                float newAlpha = expectiMiniMax(child, depth - 1, false);</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">                if (newAlpha &gt; alpha) {</span>
<span class="nc" id="L58">                    alpha = newAlpha;</span>
<span class="nc" id="L59">                    bestMove = child.move;</span>
                }
            }
        } else {
            // Simulate all free tiles as 2s or 4s
<span class="nc" id="L64">            ArrayList&lt;Pair&lt;Integer,Integer&gt;&gt; freeTiles = Board.getFreeTiles(node.tiles);</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">            for (Pair&lt;Integer, Integer&gt; tile : freeTiles) {</span>
<span class="nc" id="L66">                int[][] simulatedTiles = Arrays.stream(node.tiles).map(int[]::clone).toArray(int[][]::new);</span>

                // Add 2
<span class="nc" id="L69">                simulatedTiles[tile.getKey()][tile.getValue()] = 2;</span>
<span class="nc" id="L70">                Node child = new Node();</span>
<span class="nc" id="L71">                child.move = node.move;</span>
<span class="nc" id="L72">                child.tiles = simulatedTiles;</span>

<span class="nc" id="L74">                float newAlpha = expectiMiniMax(child, depth - 1, true);</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">                if (newAlpha &gt; 0) {</span>
<span class="nc" id="L76">                    alpha += (newAlpha * 90) / 100 * freeTiles.size();</span>
<span class="nc" id="L77">                    bestMove = child.move;</span>
                }

                // Add 4
<span class="nc" id="L81">                simulatedTiles[tile.getKey()][tile.getValue()] = 4;</span>
<span class="nc" id="L82">                child.tiles = simulatedTiles;</span>

<span class="nc" id="L84">                newAlpha = expectiMiniMax(child, depth - 1, true);</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">                if (newAlpha &gt; 0) {</span>
<span class="nc" id="L86">                    alpha += (newAlpha * 10) / 100 * freeTiles.size();</span>
<span class="nc" id="L87">                    bestMove = child.move;</span>
                }
<span class="nc" id="L89">            }</span>
        }
        //System.out.println(alpha);
<span class="nc" id="L92">        return alpha;</span>
    }

    private float heuristicValue(Node node) {
        // Evaluate the board's score
<span class="nc" id="L97">        float score = 0f;</span>
<span class="nc" id="L98">        int[][] tiles = node.tiles;</span>
<span class="nc" id="L99">        int freeTiles = Board.getFreeTiles(tiles).size();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        for (int y = 0; y &lt; tiles.length; y++) {</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            for (int x = 0; x &lt; tiles.length; x++) {</span>
<span class="nc" id="L102">                score += Math.pow(tiles[y][x], weightedTiles[y][x]) * freeTiles;</span>
            }
        }
<span class="nc" id="L105">        return score;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>